'''
Это гайд на задания 19-21.
Благодаря программе, которую надо просто зазубрить,
сделать это задание сложным весьма сложно (да, тавтология, а ты запрети),
а в рамках реального ЕГЭ вообще почти невозможно.
Есть всего несколько приколов для усложнения:
1)Больше куч
2)НЕ оптимальная игра (это теоретически может стать проблемой, но ОЧЕНЬ редко)
3)Сложные условия победы
4)Сложные варианты (например если куча четная, то так, если нет, то иначе)
5)Когда идет уменьшение
'''


# Для начала сама программа
def f(s, hod):  # На вход камни в куче и ход
    if s >= 93:  # Условие окончания, здесь это больше или равно 93 камням
        return hod % 2 == 0  # Запоминаем, но если попытаться объяснить, то это показывает нужный ли нам игрок победил
    if hod == 0:  # Если ходы закончились, а куча все ещё не та
        return 0  # То гг, вп, всем пока

    variants = [f(s+1, hod-1), f(s+2, hod-1), f(s*10, hod-1)]  # Список функций вида f(операция над кучей), hod-1)
    return any(variants) if hod % 2 != 0 else all(variants)  # Вот эту строчку зубрите, тут проще всего ошибиться
# Попытаюсь её объяснить: Нас устроит хотя бы какой-то путь к победе, если наш ход, а вот если ход противника,
# то нас уже не будет устраивать то, что он может выйграть


'''
Дальше просто генератор вида [x for x in range(допустимые значения для старта) if f(x, нужный ход)]
Нужный ход это номер хода по принципу:
ПВПВПВПВП
123456789
Когда сказано что точно В2, но не первым,  или точно В2, но может быть и В1, мы в любом случае указываем not В1
if not (f(x, 2)) and f(x, 4)
'''
print('19', [x for x in range(1, 92) if f(x, 2)])  # Ваня первым ходом
print('20', [x for x in range(1, 92) if not (f(x, 1)) and f(x, 3)])  # Петя вторым ходом
print('20', [x for x in range(1, 92) if not (f(x, 2)) and f(x, 4)])  # Ваня вторым ходом


'''_____________________________________________________________________________________________________________________
1 Несколько куч я даже не буду искать задание (там следующее с двумя кст). Нам обычно дана одна куча, 
и надо перебрать варианты второй, тогда строчку
1) f(s, hod) > f(s1, s2, hod)
2) Смотрим на условие, и меняем if s>= 90: на то что нужно, 
обычно (s1+s2)>=90:, иногда бывает s1>=90 or s2>=90:
Это не проблема обычно

3)variants = [f(s+1, hod-1), f(s+2, hod-1), f(s*10, hod-1)] надо просто добавить прибавление в другую кучу
variants = [f(s1+1, s2, hod-1), f(s1+2, s2, hod-1), f(s1*10, s2, hod-1),
            f(s1, s2+1, hod-1), f(s1, s2+2, hod-1), f(s1, s2*10, hod-1)]
            
В генераторе обычно меняется только f(x, нужный_ход) ==> f(x, 12, нужный_ход). 12 типа фиксированное начало из задачи

Если у нас обе кучи могут быть разными, то просто пишем что-то вроде:
print('19', [(x, y) for x in range(1, 92) for y in range(1, 92) if f(x, y, 2)])
Если у нас 3, 4, да хоть 1000, мы просто увеличиваем число дальшейших вариантов и переменных в функции
(можно автоматизировать, но больше 3х куч я не видел, так что вообще не обязательно надо)
В общем доп куча это напугать ежа голой жопой
'''


'''_____________________________________________________________________________________________________________________
2 Не оптимальная игра это в простейшем варианте:
Известно, что Ваня выиграл своим первым ходом после неудачного хода Пети. 
Это совсем не проблема, нам надо в последней строчке функции all заменить на any.
Главное не забыть вернуть обратно для 20 и 21
А вот если задача выглядит как:
Ваня ошибся в свой второй ход и дал пете выйграть, тут уже сложно, но я такое только раз видел, 
даже в СтатГраде такого не было.
№ 15336 Досрочная волна 2024 (Уровень: Базовый)
Вот с досрока, только 19 здесь (кст 2 кучи)
Две кучи, +1 или *2, победа когда сумма >= 123, в одной в начале 13, в другой от 1 до 109
'''


def fd(s1, s2, hod):  # Все также кроме конца
    if (s1 + s2) >= 123:
        return hod % 2 == 0
    if hod == 0:
        return 0

    variants = [fd(s1+1, s2, hod-1), fd(s1*2, s2, hod-1), fd(s1, s2+1, hod-1), fd(s1, s2*2, hod-1)]
    return any(variants) if hod % 2 != 0 else any(variants)  # Второй ТОЖЕ ANY


print('Номер 15336 ', '19', [x for x in range(1, 110 ) if fd(x, 13, 2)])  # Ваня первым ходом, после неудачного, минимальное надо


'''_____________________________________________________________________________________________________________________
3 Сложные условия победы это обычно что-то тапа:
Игра заканчивается когда камней > n. Если камней получилось от n до m, то победил последний ходивший, 
если больше m, то его соперник. Тут мы просто пишем 
if s>=n:
    if n <= s <= m:  ДА, так можно, оно так работает
        return hod % 2 == 0
    else:
        return hod % 2 != 0
В общем просто if, а в остальном так же. 
Вряд ли будет что то сложнее этого, да и в любом случае, просто if else и все
'''


'''_____________________________________________________________________________________________________________________
4 Сложные варианты ходов
Тут я знаю два подтипа:
1)Если , то.
Тут просто обычный if, например +1 +2 (*10 если четное)
variants = [f(s + 1, hod - 1), f(s + 2, hod - 1)]
if s % 2 ==):
    variants.append(f(s * 10, hod - 1))
Иногда надо формата 
if условие:
    variants = [что-то одно]
else:
    variants = [что-то совсем другое]
Но разницы не много

2) Это полностью зависящий от s варианты, например делители. 
Разберем статгдад( ну точнее только часть с созданием вариантов ходов
Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. 
Игроки ходят по очереди, первый ход делает Петя. Если в куче n камней и число n кратно k(k>1), 
то за один ход можно добавить n/k камней.
Например, если в куче 12 камней, то можно добавить 6(12/2), 4(12/3), 3(12/4), 2(12/6), 1(12/12) 
'''


def deliteli(ch):  # ЗАПОМНИТЕ ПОИСК ДЕЛИТЕЛЕЙ
    s = set()
    s.add(ch)
    for i in range(2, int(ch**0.5)+1):
        if ch % i == 0:
            s.add(i)
            s.add(ch//i)
    return list(s)


def f(s, hod):
    if s >= 41:
        return hod % 2 == 0
    if hod == 0:
        return 0
    deliteli_list = deliteli(s)  # Получаем делители
    variants = [f(s+(s//k), hod-1) for k in deliteli_list]  # Генерируем ходы, ничего особого
    return any(variants) if hod % 2 != 0 else all(variants)


print('СтатГрад', '19', [x for x in range(1, 41) if f(x, 2)])  # Ваня первым ходом, количество таких

'''
5 На уменьшение
Тут тоже все просто, там где камней становилось больше, теперь будет меньше, и условие конца меняется.
Ну и в общем то все
№ 11669 (Уровень: Базовый)
(Л. Шастин) За один ход игрок может убрать из кучи 7 камней или уменьшить количество камней в куче в 3 раза 
(количество камней, полученное при делении, округляется до меньшего).
Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней.
Игра завершается в тот момент, когда количество камней в куче становится менее 117. 
Победителем считается игрок, сделавший последний ход, т.е. первым получивший кучу из 116 или менее камней.
В начальный момент в куче было S камней, 117 ≤ S ≤ 10 000.
'''


def f(s, hod):
    if s < 117:
        return hod % 2 == 0
    if hod == 0:
        return 0
    variants = [f(s-7, hod-1), f(s//3, hod-1)]
    return any(variants) if hod % 2 != 0 else all(variants)


# В 19 неудачный ход, я скипнул
print('На уменьшение', '20', [x for x in range(117, 10_001) if not (f(x, 1)) and f(x, 3)])  # Петя вторым ходом
'''
Не хочу расписывать не первый неудачный, так что его нет
'''
