from itertools import product, permutations
import time
'''
Это полный гайд по 8 заданию.
В этом задании могут встретиться разные типы, и иногда это что-то страшное, но на ЕГЭ должно быть попроще.
Начну с основных вариаций заданий, потом разберу сложные(те которые программой еще можно)
Некоторые программой не решить, просто 10000000000 чисел потому что. Но их на ЕГЭ не должно быть.

Все в if-ах потому, что его в pycharm можно свернуть и тогда оно компактно выглядит, я думаю вы потерпите
'''


'''_____________________________________________________________________________________________________________________
Начнем с первого типа:
n-буквенные слова, с алфавитном порядке, найти обычно номера, удовлетворяющие условиям
PS Иногда алфавитный порядок это не тот который в русском алфавите, а тот который они показали в примере, 
так что sort не всегда поможет
'''
# Можно сделать так:
a = product('ПАРУС', repeat=5)
# Тогда нам во первых надо отсортировать в алфавитном(а как я уже говорил иногда алфавит у них свой):
a = sorted(a)
# И во вторых уже в переборе нам может пригодиться работать с соседними символами,
# а это удобнее делать с цельной строкой, а не с ('П', 'А', 'Р', 'У', 'С'). Так что прийдется джойнить
for i in a:
    j = ''.join(i)
    pass
# За счет небольшого усложнения строки с продуктом мы можем сразу получить список строк, да еще и в алфавитном
# Для этого внутри product ставим буквы в алфавитном порядке, и все это сразу джойним и в список
a = [''.join(x) for x in product('АПРСУ', repeat=5)]

# Дальше можно сделать так:
for ind in range(len(a)):
    i = a[ind]
    if not i:
        print(ind+1)  # А ведь +1, необходимый из-за того, что индексы с 0, а не 1, легко забыть
# Или же все таки использовать enumerate, здесь он реально упрощает.
# Напомню механику его работы: enumerate([a, b, c, d], x) > [(x, a), (x+1, b), (x+2, c), (x+3, d)]
for ind, i in enumerate(a, 1):
    if not i:
        print(ind)
# Приступим к задачам

n15320 = False
if n15320:
    '''
    №15320 КЕГЭ досрок уровень база
    Все 5-буквенные слова, в составе которых могут быть только буквы П, А, Р, У, С, записаны в алфавитном порядке и пронумерованы.
    Вот начало списка:
    1.  ААААА
    2.  ААААП
    3.  ААААР
    4.  ААААС
    5.  ААААУ
    6.  АААПА
    Под каким номером в списке идёт первое слово, которое содержит не более одной буквы У 
    и не содержит букв А, стоящих рядом?
    1)Составляем все слова, при чем сразу в алфавитном
    2)Идем по всем элементам пока не встретим подходящий
    '''
    a = [''.join(x) for x in product('АПРСУ', repeat=5)]  # Тут я уже объяснил почему удобнее сразу так писать
    print(a[:6])  # Вывод первых элементов списка, лучше проверьте себя
    for ind, i in enumerate(a, 1):  # Берем номер элемента и сам элемент
        if i.count('У') <= 1:  # Если не больше 1 У
            if 'АА' not in i:  # Если нет АА, именно для таких и стоит джойнить
                print(ind, i)  # Выводим номер, и, на всякий случай, сам элемент
                break  # Поскольку нам нужен только первый, мы просто выходим из цикла

n13823 = False
if n13823:
    '''
    №13823 КЕГЭ уровень база
    Все пятибуквенные слова, составленные из букв М, И, З, А, Н, Т, Р, О, П, записаны в алфавитном порядке
    и пронумерованы. Ниже приведено начало списка.
    1. ААААА
    2. ААААЗ
    3. ААААИ
    4. ААААМ
    5. ААААН
    6. ААААО
    7. ААААП
    8. ААААР
    Под каким номером в списке стоит последнее слово с чётным номером,
    которое начинается с буквы Н и содержит ровно две буквы Р?
    
    Тут все так же, но обратите внимание, надо сверяясь с примером не забыть Т
    '''
    a = [''.join(x) for x in product('AЗИМНОПРТ', repeat=5)]  # Опять же, ставим в порядке из примера,
    # проверяем что все буквы взяли
    print(a[:8])  # Проверяем
    for ind, i in enumerate(a, 1):  # номер, элемент
        if ind % 2 == 0:  # Если номер четный
            if i[0] == 'Н':  # Если первая буква Н
                if i.count('Р') == 2:  # Если 2 буквы Р
                    print("n13823: ", i, ind)  # То выводим.
                    # Тут по заданию в ответ последнее, так что без break
                    # Можно в переменную сохранять, что бы не спамило лишним, но это не обязательно
                    # + можно проверить работоспособнось

n13253 = False
if n13253:
    '''
    №13253 КЕГЭ уровень база
    Павел составляет два списка из слов: в одном всевозможные 5-буквенные слова,
    составленные из набора букв К, О, Н, Е, Ц, в другом всевозможные 5-буквенные слова,
    составленные из набора букв Д, Р, А, К, О, Н. 
    Каждая из допустимых букв может встречаться в словах любое количество раз или не встречаться совсем.
    Найдите количество слов, которые присутствуют только в одном из списков.
    Забавное задание, я такого не встречал раньше.
    Тут просто делаем 2 списка, и по каждому проходимся, в поиске уникальных
    '''
    konec = [''.join(x) for x in product('КОНЕЦ', repeat=5)]  # Все из конца
    drakon = [''.join(x) for x in product('ДРАКОН', repeat=5)]  # Все из дракона
    count = 0
    for i in konec:  # Проходимся по концу
        if i not in drakon:  # +1 если такого нет в драконе
            count += 1
    for i in drakon:  # то же самое, но наоборот
        if i not in konec:
            count += 1
    print(f"Номер13253: {count}")  # вот и все
    '''
    Однако это задание так же можно решить аналитически. Именно в этом это не нужно, но стоит увеличить слова, 
    так фиг ты программой посчитаешь в лоб. Решение я оставлю, но оно скорее всего вам не понадобится на ЕГЭ
    Количество всевозможных 5-буквенных слов из букв КОНЕЦ 55 = 3125
    Количество всевозможных 5-буквенных слов из букв ДРАКОН 65 = 7776
    Количество всевозможных 5-буквенных слов из букв КОН 35 = 243 (эти слова будут присутствовать в обоих списках)
    Таким образом, количество слов, которые будут только в одном из списков равно 55 + 65 - 2∙35 = 10415
    '''

nStatGrad = False
if nStatGrad:
    '''
    Десятибуквенные из букв слова СКАНЕР в алфавитном и пронумерованы начиная с 1:
    1)AAAAAAAAAА
    2)AAAAAAAAAЕ
    3)AAAAAAAAAК
    4)AAAAAAAAAН
    5)AAAAAAAAAР
    Количество слов, в которых:
    Номер кратен 3
    Первая буква согласная
    Содержит одну Р
    
    {Оно будет считать долго, но будет даже если совсем в лоб, но я приведу и более оптимальное решение}
    Забудьте предыдущую строку, мое "оптимальное решение" считало 38 секунд вместо 8 "неоптимального"
    '''
    v1 = True

    t1 = time.time()
    if v1:
        a = product('АЕКНРC', repeat=10)   # Не пропустите С
        # Я не джойню потому, что здесь это не нужно, а времени много
        count = 0
        for ind, i in enumerate(a, 1):  # Список с нуменацией с 1
            if ind % 3 == 0:  # Если номер кратен 3
                if i[0] not in 'АЕ':  # Если первая не гласная, то она согласная
                    if i.count('Р') == 1:  # Если одна Р
                        count += 1  # То мы нашли что искали
        print(f"СтатГрад, (Как выяснилось) оптимальная: {count}")  # Ура победа
        # Я по приколу оставлю свое решение, но оно гораздо медленнее
        '''
        print(time.time() - t1)
    t2 = time.time()
    v2 = True
    if v2:
        
        a = list(product('АЕКНРC', repeat=10))
        count = 0
        for i in a[2::3]:
            if i[0] != 'А' and i[0] != 'Е':
                if i.count('Р') == 1:
                    count += 1
        print(f"СтатГрад, оптимальная: {count}")
        print(time.time() - t2)'''


'''_____________________________________________________________________________________________________________________
Второй тип это количество цифр, в определенной системе счисления, в которых выполняется какое-то условие.
Тут все почти так-же
Программы обычно не сложные, но медленные. Аналитически решать это жопа, но не должно понадобиться
1)Генерируем все числа
2)Проверяем условия (и то, что не с нуля начинается)
'''

n15012 = False
if n15012:
    '''
    №15012 КЕГЭ
    Алексей составляет пятизначные числа в четырнадцатеричной системе счисления. 
    Числа должны содержать ровно две различные цифры, при этом число должно оканчиваться на 0 или на 3. 
    Сколько различных чисел может составить Алексей?
    '''
    chisla = [''.join(x) for x in product('0123456789abcd', repeat=5)]  # Здесь так-то и без join можно
    count = 0  # Счетчик
    for i in chisla:  # По каждому элементу
        if i[0] != '0':  # Если первое не 0
            if len(set(i)) == 2:  # Если есть только 2 разных цифры
                if i[-1] in '03':  # Если последний это 0 или 3
                    count += 1  # то плюс 1
    print(f"Номер 15012: {count}")  # УРА ОТВЕТ


n11827 = False
if n11827:
    '''
    №11827 КЕГЭ уровень средний
    Определите количество семизначных чисел, записанных в восьмеричной системе счисления, 
    запись которых содержит ровно две чётные цифры, и при этом никакая нечётная цифра не стоит рядом с цифрой 7.
    1)Все создаем
    2)проверяем что не с 0
    3)Проверяем количество четных
    4)проверяем что нет нч рядом с 7
    Здесь много автоматизации стоит применить
    '''
    a = [''.join(x) for x in product('01234567', repeat=7)]  # Генерируем
    ch = '0246'  # Четные
    nch = '1357'  # Не четные
    count = 0
    for i in a:  # По каждому
        if i[0] != '0':  # С 0 не может начинаться
            s_chet = sum([i.count(x) for x in ch])  # Суммируем количество каждого из четных
            if s_chet == 2:  # Если насумировали до 2, то вперед
                for x in nch:  # А теперь проверяем каждое нечетное
                    if (x+'7') in i or ('7'+x) in i:  # Если (нч)7 или 7(нч), то
                        break  # Уходим отсюдова
                else:  # else после for срабатывает если он закончился сам, без break.
                    # В нашем случае это значит что он проверил все
                    count += 1
    print(f"Номер 11827: {count}")  # Туда его


n15413 = False
if n15413:
    '''
    №15413 КЕГЭ уровень средний
    Найдите количество четырехзначных чисел в девятеричной системе счисления, 
    в которых есть ровна одна цифра 8, а сумма цифр слева от нее равна сумме цифр справа от нее.
    Примечание: если слева или справа от 8 цифр нет, то сумма считается равной нулю
    1)Генерируем все числа
    )Смотри что бы не с 0 начиналось
    2)Если одна 8
    3)То суммируем до индекса и после
    '''
    a = [''.join(x) for x in product('012345678', repeat=4)]  # Не буду повторяться
    count = 0
    for i in a:
        if i[0] != '0':
            if i.count('8') == 1:
                index_8 = i.index('8')  # Находим место восьмерки
                '''
                Разбреру следующие строки
                i[:index_8] - строка до 8
                i[index_8+1:] - строка после 8
                map(int, i[:index_8]) - Применяет int на каждый элемент
                sum(map(int, i[:index_8])) суммирует все элементы после пременения на них int
                (я думал надо sum( list(map(int, i[:index_8])) ), но sum может и просто map сложить)
                
                '''
                pre_s = sum(map(int, i[:index_8]))
                post_s = sum(map(int, i[index_8+1:]))
                if post_s == pre_s:  # Если сумма да и сумма после равны
                    count += 1  # То нам подходит
    print(count)
    '''
    Вот аналитическое решение:
    Если 8 стоит на первой позиции, есть только одно подходящее число - 8000.
    Если 8 стоит на второй позиции, то на первой может быть число от 1 до 7. 
    Вариантов представить любое число, как сумму двух чисел на один больше, чем само число
    (например для 3 есть 4 способа 0 + 3 = 1 + 2 = 2 + 1 = 3 + 0 = 3). 
    Поэтому таких чисел будет 2 + 3 + ... + 8 = (2 + 8) * 7 / 2 = 5 * 7 = 35.
    
    Если 8 стоит на третьей позиции, то на последней может быть число от 0 до 7. 
    Посколькую одна из цифр слева от 8 будет на первой позиции, то и способов представить цифру на последней, 
    как сумму двух первых, будет меньше на 1 (теперь не будет способа 0 + x = x). 
    Поэтому таких чисел будет 0 + 1 + 2 + ... + 7 = (0 + 7) * 8 / 2 = 7 * 4 = 28.
    
    Если 8 стоит на четвертой позиции, то на первой должен тоже стоять 0, поэтому таких способов нет.
    
    Ответ - это сумма всех рассмотренных вариантов 1 + 35 + 28 = 64.
    '''


'''_____________________________________________________________________________________________________________________
Третий тип это перстановка, а не все комбинации
Тут у нас вместо product будет permutation, и результат мы сначала в set закинем, так как макака и макака и макака 
это три разных варианта перестановки, но нас интересуют разные слова 
'''

n12786 = False
if n12786:
    '''
    Какое количество 6-буквенных слов вы сможете составить перестановкой букв слова «МАКАКА»?
    В данной задаче нужно принять подходящими все возможные последовательности, 
    вне зависимости имеет или нет данный набор букв смысловое содержание.
    При этом необходимо избегать слов с двумя подряд одинаковыми буквами.'''
    a = [''.join(x) for x in permutations('МАКАКА', r=6)]  # В этой задаче r не нужен, но если что это как repeat
    s = set()  # Сюда закидывать будем
    for i in a:  # По каждому
        if 'КК' not in i:  # Если нет рядом ММ
            if 'АА' not in i:  # Ели нет рядом АА
                # ММ проверять не надо, она одна всего
                s.add(i)  # В сет
    print(f"Номер 12786: {len(s)}")  # Длина множества это ответ

n5655 = False
if n5655:
    '''
    №5655 КЕГЭ уровень сложный
    Сколько существует способов разложить 4 синих, 3 красных и 2 зеленых коробки подарков вокруг елки, 
    если известно, что коробки одинаковых цветов не должны стоять рядом друг с другом.
    1)Все вариации
    2)Проверить что первый и последний не равны (у нас же вокруг елки)
    3)Проверить отсутствие СС, КК, ЗЗ
    4)Сложность оказалась в том, что 123 и 231 это для круга одно и тоже
    Я предлагаю проверять все варианты поворота, и только тогда добавлять
    '''
    a = [''.join(x) for x in permutations('ССССКККЗЗ')]  # Загадка от Жака Фреско, что делает эта строка?
    # На размышление дается один бит
    s = []  # Сюда будем закидывать, из-за специфики задачи set не нужен, все равно руками проверять надо будет
    for i in a:
        if i[0] != i[-1]:  # Если первый и последний не равен (напоминаю, у нас круг, так что они тоже рядом)
            if 'СС' not in i:  # Проверить рядом СС
                if 'КК' not in i:  # Проверить рядом КК
                    if 'ЗЗ' not in i:  # Проверить рядом ЗЗ
                        for sdvig in range(9):  # А теперь проверим все варианты, как можно покрутить эту комбинацию
                            if i[-sdvig:] + i[:-sdvig] in s:  # 012345 > 5 + 01234 и дт
                                break  # Если такой уже есть, то выходим
                        else:  # Если for завершился сам, без break
                            s.append(i)  # То добавляем
    print(s)
    print(f"Номер 5655: {len(s)}")
