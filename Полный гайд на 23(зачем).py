'''
Гайд на 23.
Зачем не знаю, но пусть будет.
С 5-го усложненые варианты, на всякий гляньте
'''


n1 = True
if n1:
    '''
    https://education.yandex.ru/ege/task/acff8759-e651-43c1-bebb-130f178d2ff6
    +3
    *2
    *5
    5 => 115 и без 25
    '''

    def f1(x, need):  # Это дли первого случая, здесь нет запрета на числа
        if x == need:  # Если в нужном числе
            return 1  # То есть 1 путь
        if x > need or x == 25:  # Если перескочили, или запретное 25
            return 0  # то пути нет
        if x < need:  # Если X пока что меньше(вообще if здесь можно скипнуть, если до сюда дошло, то всегда True)
            return f1(x+3, need) + f1(x*2, need) + f1(x*5, need)  # Ну и сумма путей от всех доступных операций


    print(f"Номер 1: {f1(5, 115)}")


n2 = True
if n2:
    '''
    https://education.yandex.ru/ege/task/6eaf2036-fd61-4725-a3d7-75021893c482
    +3
    *2
    **2
    Сколько существует программ, для которых при исходном числе 2 результатом является число 128 и траектория вычислений
    программы содержит число 12 ИЛИ не содержит числа 20.
    Видим что там четко выделено ИЛИ, значит надо только одно из условий:
    есть 12 и not(нет 20) <==> Есть 12 И есть 20
    not(есть 12) и нет 20 <==> Нет 12 И Нет 20
    Просто напишем 2 функции
    '''


    def f2_1(x, need):  # Это дли первого случая, здесь нет запрета на числа
        if x == need:  # Если в нужном
            return 1  # То есть 1 путь
        if x > need:  # Если перескочили,
            return 0  # то пути нет
        if x < need:  # Если пока что меньше(вообще if здесь можно скипнуть, если до сюда дошло, то всегда True)
            return f2_1(x+3, need) + f2_1(x*2, need) + f2_1(x**2, need)  # Ну и сумма путей от всех доступных операций


    def f2_2(x, need):  # А вот эта для второго случая, тут не должно быть 12 и 20
        if x == need:
            return 1
        if x > need or x == 12 or x == 20:  # Если x равен 12 или 20, то тоже выходим из программы
            return 0
        if x < need:  # Опять же, if здесь для порядка просто
            return f2_2(x+3, need) + f2_2(x*2, need) + f2_2(x**2, need)


    # Ответ при условии заходу в какую-то точку это произведение количества путей между точками
    print(f"Номер 2. От 2 до 12: {f2_1(2, 12)}, от 12 до 20: {f2_1(12, 20)}, от 20 до 128: {f2_1(20, 128)}\n"
          f"Номер 2. Всего путей для первого случая: {f2_1(2, 12) * f2_1(12, 20) * f2_1(20, 128)} ")
    print(f"Номер 2. Путей для второго случая: {f2_2(2, 128)}")  # Ну а тут сразу до 128, исключаем точки мы в программе
    print("Номер 2. Ответ это сумма двух случаев")



n3 = True
if n3:
    '''
    Тут на уменьшение. Все работает так же, только знаки меняем
    https://education.yandex.ru/ege/task/acff8759-e651-43c1-bebb-130f178d2ff6
    -2
    -5
    23=>2
    '''
    def f3(x, need):
        if x == need:
            return 1
        if x < need:  # Тут меняем больше на меньше (теперь мы перескакиваем вниз)
            return 0
        if x > need:  # Тут меньше меняем на больше
            return f3(x-2, need) + f3(x-5, need)


    print(f"Номер 3: {f3(23, 2)}")

n4 = True
if n4:
    '''
    https://education.yandex.ru/ege/task/3e667a69-58b0-43b2-8e2e-7cff89105841
    Отними первую цифру квадрата числа
    Отними сумму цифр числа
    32 => 1
    '''
    def f4(x, need):
        if x == need:
            return 1
        if x < need:
            return 0
        x1 = x - int(str(x**2)[0])  # X - первая цифра квадрата
        x2 = x - sum(map(int, str(x)))  # X - сумма цифр. То же самое что x - sum([int(i) for i in str(x)])
        return f4(x1, need) + f4(x2, need)


    print(f"Номер 4: {f4(32, 1)}")


n5 = True
if n5:
    '''
    https://education.yandex.ru/ege/task/fff68292-d79a-42b4-b357-0e2355cd43c2
    +3
    *3
    Сколько нечётных чисел, меньших 100, может быть получено в результате работы исполнителя, 
    если на вход Сумножатору будет подано число 10?
    1)Здесь у нас нет конца, но если больше 100, то дальше нет смысла.
    2)Каждое число, которое мы получили в процессе надо сохранять, ведь это возможный результат
    '''
    def f5(x):  # Тут надо передавать только число, конец у нас постоянный
        if x < 100:  # Если меньше 100
            if x % 2 != 0:  # То если нечетное
                s.add(x)  # То это подходящий результат
            f5(x+3)  # И в любом случае идем дальше
            f5(x*3)  # Тут return не нужен. Мы сохраняем в самой функции


    s = set()  # Для ответа
    f5(10)  # Вызываем от 10
    print(f"Номер 5: {len(s)}")  # Нужно количество


n6 = True
if n6:
    '''
    https://education.yandex.ru/ege/task/f96caa93-afc7-4ca1-8fff-374f264b4ba8
    +2
    *3
    **3
    Программа для исполнителя – это последовательность команд. Необходимо найти количество существующих программ,
    для которых при исходном числе 3 результатом является число 125, 
    при этом траектория вычислений не содержит числа 27 и содержит не более 15 команд.
    Тут в функции есть ещё счетчик команд, если 15 раз уже сделали, а результата ещё нет, то тоже ноль
    '''
    def f6(x, need, count):  # Ещё одна переменная - счетчик количества выполненных команд
        if x == need:  # Если число
            return 1  # То путь есть
        if x > need or count == 15 or x == 27:  # Если перескочили ИЛИ уже 15 команд, а результата нет ИЛИ число == 27
            return 0  # то ТЫ НЕ ПОЙДЕШЬ
        if x < need:
            return f6(x+2, need, count+1) + f6(x*3, need, count+1) + f6(x**3, need, count+1)  # Счетчик операций +1


    print(f"Номер 6: {f6(3, 125, 0)}")  # В начале операций ещё не делали, поэтому 0

n7 = True
if n7:
    '''
    https://education.yandex.ru/ege/task/ba109d7d-5e51-4b2c-a9b1-892eec08a4db
    +1
    +2
    *2
    Сколько существует таких программ, которые исходное число 3 преобразуют в число 25 
    и при этом в программе есть все три команды?
    Я думаю надо сделать переменные под каждую команду, и если мы её использовали, то ставить True
    '''
    def f7(x, need, p1, p2, m2):  # Добавляем переменые плюс1 плюс2 множить2
        if x == need:  # Если пришли в число
            if p1 and p2 and m2:  # Если всё использовали
                return 1  # То кайфуем
            else:  # Иначе
                return 0  # ГГ
        if x > need:  # Тут так же как и всегда
            return 0
        if x < need:
            # Функция теперь выглядит как f7(x[операция], need, p1, p2, m2). Надо поставить операцию и True
            # вместо соответствующей переменной(p1 p2 m2)
            return f7(x+1, need, True, p2, m2) + f7(x+2, need, p1, True, m2) + f7(x*2, need, p1, p2, True)


    print(f"Номер 7: {f7(3, 25, False, False, False)}")  # Изначально ни одну операцию мы не использовали


n8 = True
if n8:
    '''
    https://education.yandex.ru/ege/task/fc7ab1b0-2ae1-4379-9e30-36ebb7b1683f
    +1
    *2
    *3
    Сколько существует непустых программ, для которых при исходном чётном положительном числе 
    результатом работы является число 15?
    '''
    def f8(x, need):  # Самая базовая программа
        if x == need:
            return 1
        if x > need:
            return 0
        if x < need:
            return f8(x+1, need) + f8(x*2, need) + f8(x*3, need)


    s = 0  # Будем суммировать
    for i in range(2, 100, 2):  # Перебираем четные положительные.
        s += f8(i, 15)  # Прибавляем количество программ из этого числа
    print(f"Номер 8: {s}")

'''
Тут можно придумать ещё много усложнений, но все они не такие проблемные. 
Они всегда решаются парой не сложных строк или доп переменными в функции
'''
