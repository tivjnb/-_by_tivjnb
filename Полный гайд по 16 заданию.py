from functools import lru_cache
from time import time
'''
Это полный гайд по 16 заданию.
Тут всегда можно считать в лоб, и если использовать lru_cache, то проблем быть не должно.
Но иногда эти задания за минуту решаются руками (там нет сложных расчетов). Начнем с тех, которые так можно
'''

'''
Алгоритм вычисления значения функции F(n), где n — натуральное число, задан следующими соотношениями:
f(n) = 1/2 при n <= 1
f(n) = (n+1)*f(n-1)
Чему равно f(200)/f(198)
Первый вариант - посчитать программой, просто рекурсивная функция и поехали.
Но когда мы видим деление или вычитание двух функций мы с большой вероятностью имеем возможность провернуть один прикол:
Что такое f(200) в этом примере?
f(200) = (200+1)*f(199) Продолжим раскрывать функции
f(200) = (200+1)*f(199) = (200+1) * (199+1) * f(198) Мы дошли до второй функции
Давайте запишем наше выражение по другому:
f(200)/f(198) <==> ((200+1) * (199+1) * f(198))/f(198)  <==> 201*200 = 40200
И все, если числа большие, то просто в компилятор их и всё, ответ.
Но программу в любом случае
'''


@lru_cache(None)  # С помощью него программа будет запоминать результат работы функции для конкретного n
def f(n):  # Сама функция
    if n <= 0:  # Тут просто условия с задачи
        return 1/2
    else:
        return (n+1) * f(n-1)


print(f(200)/f(198), "Программа не работает, большие числа, см решение ручками")
# ААХаххахХАХАХАх, это нельзя программой решить, числа слишком больше АхахахахАхХАХАха



'''
f(n) = 1 при n <= 12
f(n) = f(n-1) + n -2
f(2024)-f(2020)
Теперь надеюсь сработает программой. 
На этот раз не деление и умножение, а вычитание и сложение
Но для начала ручками
f(2024) = 2022 + f(2023) = 2022 + 2021 + f(2022) = 2022 + 2021 + 2020 + f(2021) = 2022 + 2021 + 2020 + 2019 + f(2020)
f(2024) - f(2020) = 2022 + 2021 + 2020 + 2019 + f(2020) - f(2020) = 8082
'''


@lru_cache(None)  # Ну тут такая же
def f(n):
    if n <= 12:
        return 1
    else:
        return f(n-1) + n - 2


for i in range(400, 2000, 400):  # Что бы не ругалось на рекурсию надо прогнать в холостую
    f(i)
print(f(2024)-f(2020))  # Ну и ответ

'''
А теперь противное руками.
Но программа та же самая
№ 13297 Открытый курс "Слово пацана" (Уровень: Базовый)
(М. Попков) Алгоритм вычисления функций F(n) и G(n) задан следующими соотношениями:
*Смотрите в программу*
Определите число, которое получится, если в обе функции передать аргумент n=9 
и сложить получившиеся значения.
'''
t1 = time()


@lru_cache(None)
def f2(n):
    if n == 3:
        return 1
    else:
        return 5*f2(n-1) + 6*g2(n-1) - 3*n + 8

@lru_cache(None)
def g2(n):
    if n == 3:
        return 1
    else:
        return 6*f2(n-1) + 5*g2(n-1) + 3


print(f"Номер 13297: {f2(9) + g2(9)}")


'''
№ 13299 Открытый курс "Слово пацана" (Уровень: Базовый)
Алгоритм вычисления функции F(n), где n – натуральное число, задан следующими соотношениями:
F(n) =1, при n⩽3,
F(n)=F(n/3)+4n, при n, кратном трём, и если n>3
F(n)=n×n×n−26, при n некратном трём, и если n>3
'''
@lru_cache(None)
def f3(n):
    if n <= 3:
        return 1
    elif n % 3 == 0:
        return f3(n//3)+ 4*n
    else:
        return n*n*n - 26


last = 0
for i in range(1, 1000):
    if f3(i) < 300:
        last = i
        # print(f"Номер 13299: {i} (Берем последнее)") Ладно, го по нормальному
print(f"Номер 13299: {last}")

'''
Ну а всякие гробы, которые надо аналитически решать фиг распишешь
Просто запомните 2 строки:
from functools import lru_cache
@lru_cache(None)

И большинство заданий у вас в руках.
'''