'''
Это по возможности подробный гайд по 15.
Есть два типа:
1)A это одно число. Это всегда пишется простой програмой
2)A это числовой отрезок. Тут уже зачастую проще на бумажке, упростив операции.
Но для обоих типов внимательно смотрите на то, какого типа должны быть x y a:
натурацльные, просто целые, или может не неагтивные
'''

'''_____________________________________________________________________________________________________________________
Когда A это одно число, нам достаточно перебрать взможные значения, и для каждое проверить на разных x и y.

Сразу к задаче. 
Сколько существует целых значений А, при которых формула
((x<A)→(x⋅x≤169))∧((y⋅y<16)→(y≤A))
тождественно истинна (то есть принимает значение 1 при любых целых неотрицательных значениях переменных x и y)?
Я напишу сразу 3 вариации программы в 1 цикле, в конце сравним ответы (они одинаковые)
'''


def f_1(a, x, y):  # Всегда помещайте выражение в функцию, так гораздо удобнее.
    return ((x < a) <= (x * x <= 169)) and ((y * y < 16) <= (y <= a))  # Собственно говоря, возвращаем результат


count_1 = 0  # Я покажу сразу 2 способа, поэтому 2 счетчика
count_2 = 0
count_3 = 0
for a in range(-100, 100):  # целых значений А, поэтому отрицательные тоже можно взять
    '''
    all([]) вернет True если всё в списке True

    [f_1(a, x, y) for x in range(0, 100) for y in range(0, 100)]
    Список результатов функции для данного A и всех вариантов x y (всех в указанном range)
    Не перепутайте порядок переменных в функцию
    '''
    if all([f_1(a, x, y) for x in range(0, 100) for y in range(0, 100)]):  # x и y - целые не отрицательные,поэтому от 0
        count_2 += 1  # Если на всех x y при этом A получилось TRUE, то подходит

    for x in range(0, 100):  # По X
        for y in range(0, 100):  # По Y
            if not (f_1(a, x, y)):  # Если при этом A возможен False
                break  # То выходим из цикла
        else:  # Если цикл завершмлся сам (те было False)
            continue  # То идем проверять слеующий X
        break  # А вот если цикл завершился break, то остальные X проверять уже не надо, тоже выходим
    else:  # Если и все X проверило и не оборвалось
        count_1 += 1  # То тогда +1

    flag = True  # Ну и предыдущий вариант, но с флагом
    for x in range(0, 100):  # Так же по x
        for y in range(0, 100):  # По y
            if not (f_1(a, x, y)):  # Если есть False
                flag = False  # То флаг меняем на False
                break  # И выходиим
        if not flag:  # Если flag == False
            break  # То дольше проверять нет смылса
    if flag:  # Если после цикло flag все ещё True, значит A подходит
        count_3 += 1
print(f"Номер 1 v1: {count_1}")
print(f"Номер 1 v2: {count_2}")
print(f"Номер 1 v3: {count_3}")

'''
№ 9162 Джобс 06.06.2023 (Уровень: Средний)
Обозначим ПЛОЩ(a, b, c) утверждение «Площадь прямоугольника со сторонами a и b больше c». 
Найдите наибольшее целое значение А, при котором выражение
¬ПЛОЩ(x, y, A+13) → ПЛОЩ(28, y, 520) ∨ ПЛОЩ(x, 25, 800)
тождественно истинно, то есть принимает значение 1 при любых натуральных значениях x и y.
Тут просто надо написать ещё одну функцию, для сложного условия
'''


def plosh(a, b, c):  # Функция для условия
    return (a * b) > c


def f_2(a, x, y):  # Функция для выражения
    return ((not (plosh(x, y, a + 13))) <= plosh(28, y, 520)) or plosh(x, 25, 800)


for a in range(-100, 100):  # А - целые, и в выражении она как длинна(которая всегда +) она не фигурирует,
    # поэтому с отрицательных
    if all([f_2(a, x, y) for x in range(1, 100) for y in range(1, 100)]):  # x и y - натуральные, поэтому от 0
        print(f"№ 9162: {a}")

'''_____________________________________________________________________________________________________________________
Второй тип
Тут программы нормальной я не знаю, да и обычно достаточно взять бумажку, слегка упростить выражение и нарисовать
Обычно нужны всего пару переходов
1)A <= B <==> not(A) or B
2)not(A and B) <==> not(A) or not(B)
3)not(A or B) <==> not(A) and not(B)

'''
'''
(
№ 15330 Досрочная волна 2024 (Уровень: Базовый)
B=[24;90] и C=[47;115]
(x∈C)→((¬(x∈A)∧(x∈B))→¬(x∈C)) Сначала уберем импликацию(<=, →) внутри скобок (правило 1)
(x∈C)→(¬(¬(x∈A)∧(x∈B)) or ¬(x∈C)) Теперь НЕ перед скобкой раскорем (правило 2)
(x∈C)→((x∈A) or ¬(x∈B) or ¬(x∈C)) Уберем импликацию (правило 1)
¬(x∈C) or (x∈A) or ¬(x∈B)) or ¬(x∈C) Уберем 2 одинаковых НЕ С
(x∈A) or ¬(x∈B)) or ¬(x∈C)
теперь рисуем
       B(       C(    )B      )C
______24_______47_____90_____115_____
111111(24              90)11111111111 ¬(x∈B))
11111111111111(47            115)1111 ¬(x∈C)
Соответственно надо докинуть 1 туда, где их нет, а это 47 - 90 включительно
Длинна это если что именно длина, а не количество 1, так что просто 90 - 47 = 43
'''

'''
Я программу сам недавно придумал, ещё не тестил особо, но в чем суть:
нам необходимо что бы на любом X была ИСТИНА.
Проверяем для каждого числа, будет ли там истина без A. (функция по умолчанию берет А за ложь)
Если без А там не получается, то значит оно там должно быть.



'''

b = range(24, 91)  # Не забываем что последнее число +1
c = range(47, 116)
def f(x):  # Функция для проверки в точке Х
    a = False  # А по умолчанию false
    return (x in c) <= (((not a) and (x in b)) <= (x not in c))  # Функция, где принадлежность А заменяется на
    # просто А или НЕ А в зависимости от того что нам надо


ls = []  # Для необходимых А шек
for x in range(0, 200):  # Проверим все Х
    if not f(x):  # Если фунция без А в этом Х ложна
        ls.append(x)  # То в этой точке А должно быть истиной
print(ls)  # Выводим просто проверить
print(len(ls))  # Надо вычесть 1, потому что нам нужна длина отрезка (смотри объяснение дальше)


'''
Надо наверное про длину объяснить.
Почему длина не совпадает с количеством?
у нас не просто множество целых чисел, а непрерывный отрезок. 
Помните математику, круглые квадратные скобки? Вот это оно как раз
Соответственно отрезок [47 - 90] это от 90 до 47 включительно.
Покажу на черепахе:
Точек 5, а длина 4
PS Именно здесь у нас числовой отрезок, а в других заданиях (других типов) может быть именно множество целых чисел
'''
from turtle import *
tracer(0)
for _ in range(4):
    dot(5, 'black')
    forward(40)
dot(5, 'black')
done()
